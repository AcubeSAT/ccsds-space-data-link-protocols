#!/bin/env python3

import os
from argparse import ArgumentParser

"""
Naive parser and pretty printer for the MISRA reports by cppcheck.

Usage:
python3 summarizer.py --report <report-file-generated-from-cppcheck-misra.sh> 
--suppress <list-of-rule-numbers-to-be-suppressed> (as they are given on the
MISRA handbook)

e.g.: python3 summarizer.py --report ci/report.msr --suppress 5.2 10.4 15.5

You can also mark lines you wish to be skipped by adding 
"// Ignore-MISRA" at a suitable position on the line you want to ignore
from assessing (NOTE: the double slashes are part of the string!)

(Credits to @dimst23 for the feature!)

TODO: Keep track of line numbers and filenames of suppressed lines.
"""


class Summarizer(object):
    def __init__(self, report_name, suppression_list):
        with open(report_name, 'r') as f:
            self.file_lines = f.readlines()  # read the report file
        f.close()

        self.red = "\033[91m"  # terminal colors
        self.yellow = "\033[93m"
        self.green = "\033[92m"
        self.bold = "\033[1m"
        self.end = "\033[0m"

        self.violations_map = {}  # dictionary containing filenames, rule violations and line where the violation
        # occurred
        self.suppression_list = suppression_list  # list of rule numbers to be suppressed

    def analyze(self):
        """
        A really dumb parser for the pre-processed report generated by cppcheck
        """

        lines_seen = set()  # contains the unique lines from the file

        for line in self.file_lines:  # remove duplicate lines
            if line not in lines_seen:
                lines_seen.add(line)

                line_contents = line.split(':')
                file_name = line_contents[0]  # first part is the filename (index 0)
                violation = (line_contents[1], line_contents[2].strip(
                    '\n'))  # index 1 is the line number, index 2 is the number of violated rule (both are strings)
                
                with open(os.path.abspath(file_name)) as code_file:
                    code_lines = code_file.readlines()  # Read the source code file
                    line_of_interest = code_lines[int(violation[0]) - 1]  # Get the desired violation line
                if line_of_interest.find("// Ignore-MISRA") >= 0 or line_of_interest.find("/* Ignore-MISRA */") >= 0:
                    continue

                if file_name not in self.violations_map.keys():
                    self.violations_map[
                        file_name] = list()  # create a new list for the new filename and append the tuple w/ line &
                    # rule no.
                    self.violations_map[file_name].append(violation)
                else:
                    self.violations_map[file_name].append(violation)  # do not create a key if it already exists

        for e in self.suppression_list:
            for file_name in self.violations_map.keys():
                self.violations_map[file_name] = [x for x in self.violations_map[file_name] if x[1] != str(e)]
                # replace the list of infractions with a new one, containing everything except the suppressed rules

        self.violations_map = {k: v for (k, v) in self.violations_map.items() if len(v) != 0}
        # "delete" all keys whose lists are empty


    def pretty_print_violations(self):
        """
        Just a pretty printing function, no fancy logic here.
        """
        print(self.bold + self.red + "=========================================================\n" + self.end)
        print(self.bold + self.red + "       Static analysis results: Infraction summary        \n" + self.end)
        for file_name in self.violations_map:
            print("")
            for violation in sorted(self.violations_map[file_name], key=lambda x: int(x[0])):
                
                name_string = f"{self.bold}{self.red}File {self.yellow}{file_name}{self.red}"
                rule_violated_string = f"violates rule {self.yellow}#{violation[1]}{self.red} " \
                    f"of the MISRA C 2012 standard"
                line_number_string = f"at line {self.yellow}{violation[0]}{self.end}"

                print(f"{name_string.ljust(75)} {rule_violated_string} {line_number_string}")

        print("")
        print("")
        print(self.bold + self.red + "=================================================" + self.end)

    def suppression_info(self):
        """
        Pretty-prints the suppressed rule numbers.
        """
        if (len(self.suppression_list) != 0):
            print("\n")
            print(self.bold + self.yellow + "WARNING: Suppressed infractions of rules: ", end="")
            print(f", ".join(self.suppression_list), end=".")
            print("")
            print("")
        else:
            print(self.bold + self.green + "All available rules enforced - no suppressions")


if __name__ == "__main__":
    cli = ArgumentParser()
    cli.add_argument("--report", nargs=1, default="./report.msr")
    cli.add_argument("--suppress", nargs="*", type=str, default="")

    args = cli.parse_args()
    s = Summarizer(str(args.report[0]), args.suppress)
    s.analyze()
    s.suppression_info()

    if len(s.violations_map) != 0:
        s.pretty_print_violations()
        exit(127)
    elif len(s.violations_map) == 0:
        print(s.bold + s.green + "Static analysis for MISRA compliance complete. No infractions found." + s.end)
        exit(0)
